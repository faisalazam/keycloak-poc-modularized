{
	"info": {
		"_postman_id": "63180889-acc8-4de8-add1-48fb453b391d",
		"name": "Keycloak",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "39468559"
	},
	"item": [
		{
			"name": "User/Auth Management",
			"item": [
				{
					"name": "Login",
					"item": [
						{
							"name": "Login - Admin",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 200', function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('Response body contains access token', function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.have.property('access_token');",
											"});",
											"",
											"pm.test('Log token for debugging', function () {",
											"    const jsonData = pm.response.json();",
											"    console.log('Admin Access Token:', jsonData.access_token.substring(0, 60) + '...');",
											"});",
											"",
											"pm.test('Handle error if status code is not 200', function () {",
											"    if (pm.response.code !== 200) {",
											"        console.error('Error: Expected 200 but got', pm.response.code);",
											"        throw new Error('Unexpected status code: ' + pm.response.code);",
											"    }",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "client_id",
											"value": "{{ADMIN_CLIENT_ID}}"
										},
										{
											"key": "username",
											"value": "admin"
										},
										{
											"key": "password",
											"value": "admin"
										},
										{
											"key": "grant_type",
											"value": "password"
										}
									]
								},
								"url": {
									"raw": "{{BASE_URL}}/realms/{{ADMIN_REALM_NAME}}/protocol/openid-connect/token",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{ADMIN_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"token"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - User",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 200', function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('Response body contains access token', function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.have.property('access_token');",
											"});",
											"",
											"pm.test('Log token for debugging', function () {",
											"    const jsonData = pm.response.json();",
											"    console.log('User Access Token:', jsonData.access_token.substring(0, 60) + '...');",
											"});",
											"",
											"pm.test('Handle error if status code is not 200', function () {",
											"    if (pm.response.code !== 200) {",
											"        console.error('Error: Expected 200 but got', pm.response.code);",
											"        throw new Error('Unexpected status code: ' + pm.response.code);",
											"    }",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "username",
											"value": "kzuser1",
											"type": "text"
										},
										{
											"key": "password",
											"value": "password1",
											"type": "text"
										},
										{
											"key": "grant_type",
											"value": "client_credentials",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{USER_MGMT_CLIENT_ID}}",
											"type": "text"
										},
										{
											"key": "client_secret",
											"value": "{{USER_MGMT_CLIENT_SECRET}}",
											"type": "text"
										}
									]
								},
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/token",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"token"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Logout",
					"item": [
						{
							"name": "1 - Login - User",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    const jsonData = pm.response.json();",
											"    const currentFolder = FolderNames.logoutFolder;",
											"    FolderVariables.setVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\", jsonData.access_token);",
											"",
											"    console.log(`USER_ACCESS_TOKEN for ${currentFolder} set to: ${jsonData.access_token.substring(0, 60) + '...'}`);",
											"",
											"    pm.test(\"Login - User: Access token retrieved and stored\", function () {",
											"        pm.expect(jsonData.access_token).to.exist;",
											"        pm.expect(FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\")).to.eql(jsonData.access_token);",
											"    });",
											"} catch (e) {",
											"    pm.test(\"Login - User: Error in setting access token\", function () {",
											"        throw new Error(\"Failed to parse access token from response\");",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "username",
											"value": "kzuser1",
											"type": "text"
										},
										{
											"key": "password",
											"value": "password1",
											"type": "text"
										},
										{
											"key": "grant_type",
											"value": "client_credentials",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{USER_MGMT_CLIENT_ID}}",
											"type": "text"
										},
										{
											"key": "client_secret",
											"value": "{{USER_MGMT_CLIENT_SECRET}}",
											"type": "text"
										}
									]
								},
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/token",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"token"
									]
								}
							},
							"response": []
						},
						{
							"name": "2 - Logout - User",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"try {",
											"    const currentFolder = FolderNames.logoutFolder;",
											"    const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"",
											"    if (accessToken) {",
											"        pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);",
											"        console.log(`Using USER_ACCESS_TOKEN for logout: ${accessToken.substring(0, 60) + '...'}`);",
											"    } else {",
											"        throw new Error(\"USER_ACCESS_TOKEN is not set in folder-level variables\");",
											"    }",
											"} catch (e) {",
											"    console.error(e.message);",
											"    pm.test(\"Logout - User: Error setting refresh token\", function () {",
											"        throw new Error(\"Failed to set USER_ACCESS_TOKEN before logout\");",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Logout - User: Logout request successful\", function () {",
											"    pm.response.to.have.status(200);",
											"    console.log(\"Logout - User: Successfully logged out with 200 status.\");",
											"});",
											"",
											"pm.test('Handle error if status code is not 200', function () {",
											"    if (pm.response.code !== 200) {",
											"        console.error('Error: Expected 200 but got', pm.response.code);",
											"        throw new Error('Unexpected status code: ' + pm.response.code);",
											"    }",
											"});",
											"",
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"console.log(\"USER_ACCESS_TOKEN cleared from environment\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "client_credentials",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{USER_MGMT_CLIENT_ID}}",
											"type": "text"
										},
										{
											"key": "client_secret",
											"value": "{{USER_MGMT_CLIENT_SECRET}}",
											"type": "text"
										},
										{
											"key": "access_token",
											"value": "{{USER_ACCESS_TOKEN}}",
											"type": "text"
										}
									]
								},
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/logout",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"logout"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Get User Info",
					"item": [
						{
							"name": "1 - Login - User",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const jsonData = pm.response.json();",
											"const currentFolder = FolderNames.userInfoFolder;",
											"pm.test('User Login: Status code should be 200', function () {",
											"    pm.response.to.have.status(200);",
											"    console.log('User login successful with status code 200.');",
											"});",
											"if (jsonData && jsonData.access_token) {",
											"    FolderVariables.setVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\", jsonData.access_token);",
											"    console.log('User access token set successfully.');",
											"} else {",
											"    console.error('Error: No access token found in response.');",
											"    pm.test('User Login: Access token should be present', function () {",
											"        pm.expect(jsonData.access_token).to.exist;",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "client_credentials",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{USER_MGMT_CLIENT_ID}}",
											"type": "text"
										},
										{
											"key": "client_secret",
											"value": "{{USER_MGMT_CLIENT_SECRET}}",
											"type": "text"
										}
									]
								},
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/token",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"token"
									]
								}
							},
							"response": []
						},
						{
							"name": "2 - Get User (Name)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"const username = pm.request.url.query.get(\"username\");",
											"const user = Utilities.getUserIdByCriteria(pm, username, \"username\");",
											"pm.test('Get User (Name): User retrieval status should be 200', function () {",
											"    pm.response.to.have.status(200);",
											"    console.log('User retrieval successful with status code 200.');",
											"});",
											"if (user && user.userId) {",
											"    const currentFolder = FolderNames.userInfoFolder;",
											"    FolderVariables.setVariable(pm, currentFolder, \"USER_ID\", user.userId);",
											"    console.log(`USER_ID for ${currentFolder} is:`, user.userId);",
											"} else {",
											"    console.error('Error: User not found or userId is missing.');",
											"    pm.test('Get User (Name): User should exist and have userId', function () {",
											"        pm.expect(user).to.exist;",
											"        pm.expect(user.userId).to.exist;",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.userInfoFolder;",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"if (accessToken) {",
											"    pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);",
											"    console.log('User access token set in environment.');",
											"} else {",
											"    console.error('Error: User access token not found in environment.');",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									},
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/users?username=user3&exact=true&briefRepresentation=true",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"users"
									],
									"query": [
										{
											"key": "username",
											"value": "user3"
										},
										{
											"key": "exact",
											"value": "true"
										},
										{
											"key": "briefRepresentation",
											"value": "true"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "3 - Get User Info",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ID\");",
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"pm.test('Get User Info: Response status should be 200', function () {",
											"    pm.response.to.have.status(200);",
											"    console.log('User info fetched successfully with status code 200.');",
											"});",
											"pm.test('User info should have valid structure', function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.have.property('id');",
											"    pm.expect(jsonData).to.have.property('username');",
											"    console.log('User info structure validated.');",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.userInfoFolder;\r",
											"const userId = FolderVariables.getVariable(pm, currentFolder, \"USER_ID\");\r",
											"if (userId) {\r",
											"    pm.environment.set(\"USER_ID\", userId);\r",
											"    console.log(`User ID set for deletion: ${userId}`);\r",
											"} else {\r",
											"    console.error('Error: User ID not found for deletion.');\r",
											"    pm.test('User ID should be available for deletion', function () {\r",
											"        pm.expect(userId).to.exist;\r",
											"    });\r",
											"}\r",
											"\r",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");\r",
											"pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}"
									}
								],
								"url": {
									"raw": "{{BASE_URL}}/admin/realms/{{USER_REALM_NAME}}/users/{{USER_ID}}",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"users",
										"{{USER_ID}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Delete User",
					"item": [
						{
							"name": "1 - Login - User",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const jsonData = pm.response.json();",
											"const currentFolder = FolderNames.deleteUserFolder;",
											"pm.test('User Login: Status code should be 200', function () {",
											"    pm.response.to.have.status(200);",
											"    console.log('User login successful with status code 200.');",
											"});",
											"if (jsonData && jsonData.access_token) {",
											"    FolderVariables.setVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\", jsonData.access_token);",
											"    console.log('User access token set successfully.');",
											"} else {",
											"    console.error('Error: No access token found in response.');",
											"    pm.test('User Login: Access token should be present', function () {",
											"        pm.expect(jsonData.access_token).to.exist;",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "client_credentials",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{USER_MGMT_CLIENT_ID}}",
											"type": "text"
										},
										{
											"key": "client_secret",
											"value": "{{USER_MGMT_CLIENT_SECRET}}",
											"type": "text"
										}
									]
								},
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/token",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"token"
									]
								}
							},
							"response": []
						},
						{
							"name": "2 - Get User (Name)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"const username = pm.request.url.query.get(\"username\");",
											"const user = Utilities.getUserIdByCriteria(pm, username, \"username\");",
											"pm.test('Get User (Name): User retrieval status should be 200', function () {",
											"    pm.response.to.have.status(200);",
											"    console.log('User retrieval successful with status code 200.');",
											"});",
											"if (user && user.userId) {",
											"    const currentFolder = FolderNames.deleteUserFolder;",
											"    FolderVariables.setVariable(pm, currentFolder, \"USER_ID\", user.userId);",
											"    console.log(`USER_ID for ${currentFolder} is:`, user.userId);",
											"} else {",
											"    console.error('Error: User not found or userId is missing.');",
											"    pm.test('Get User (Name): User should exist and have userId', function () {",
											"        pm.expect(user).to.exist;",
											"        pm.expect(user.userId).to.exist;",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.deleteUserFolder;",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"if (accessToken) {",
											"    pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);",
											"    console.log('User access token set in environment.');",
											"} else {",
											"    console.error('Error: User access token not found in environment.');",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									},
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/users?username=user8&exact=true&briefRepresentation=true",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"users"
									],
									"query": [
										{
											"key": "username",
											"value": "user8"
										},
										{
											"key": "exact",
											"value": "true"
										},
										{
											"key": "briefRepresentation",
											"value": "true"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "3 - Delete User - Admin",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.deleteUserFolder;",
											"const userId = FolderVariables.getVariable(pm, currentFolder, \"USER_ID\");",
											"if (userId) {",
											"    pm.environment.set(\"USER_ID\", userId);",
											"    console.log(`User ID set for deletion: ${userId}`);",
											"} else {",
											"    console.error('Error: User ID not found for deletion.');",
											"    pm.test('User ID should be available for deletion', function () {",
											"        pm.expect(userId).to.exist;",
											"    });",
											"}",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"if (accessToken) {",
											"    pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);",
											"    console.log('User access token set in environment.');",
											"} else {",
											"    console.error('Error: User access token not found in environment.');",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ID\");",
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"pm.test(\"Delete User: User should be deleted successfully\", function () {",
											"    pm.response.to.have.status(204);",
											"    console.log('User successfully deleted with status code 204.');",
											"});",
											"pm.test('Ensure no unexpected error during deletion', function () {",
											"    if (pm.response.code !== 204) {",
											"        console.error('Error: Unexpected status code during user deletion: ' + pm.response.code);",
											"    }",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{BASE_URL}}/admin/realms/{{USER_REALM_NAME}}/users/{{USER_ID}}",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"users",
										"{{USER_ID}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "4 - Get User (Name) - Admin",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ID\");",
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"const username = pm.request.url.query.get(\"username\");",
											"",
											"try {",
											"    const user = Utilities.getUserIdByCriteria(pm, username, \"username\");",
											"",
											"    if (!user || !user.userId) {",
											"        console.log(\"Negative Test: User not found or userId is missing as expected.\");",
											"        pm.test(\"Negative Test - User retrieval should return no data\", function () {",
											"            pm.expect(user, \"User data should be empty or undefined\").to.be.oneOf([undefined, null]);",
											"        });",
											"    } else {",
											"        console.error(\"Error: Unexpected user data found.\");",
											"        pm.test(\"Negative Test - User retrieval should not return valid user ID\", function () {",
											"            pm.expect(user.userId, \"Unexpected userId found\").to.not.exist;",
											"        });",
											"    }",
											"} catch (error) {",
											"    console.error(\"Negative Test: Exception caught during user retrieval\", error.message);",
											"    pm.test(\"Negative Test - User retrieval should handle exceptions gracefully\", function () {",
											"        pm.expect(error, \"Exception thrown as expected\").to.exist;",
											"    });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.deleteUserFolder;",
											"const userId = FolderVariables.getVariable(pm, currentFolder, \"USER_ID\");",
											"if (userId) {",
											"    pm.environment.set(\"USER_ID\", userId);",
											"    console.log(`User ID set for deletion: ${userId}`);",
											"} else {",
											"    console.error('Error: User ID not found for deletion.');",
											"    pm.test('User ID should be available for deletion', function () {",
											"        pm.expect(userId).to.exist;",
											"    });",
											"}",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"if (accessToken) {",
											"    pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);",
											"    console.log('User access token set in environment.');",
											"} else {",
											"    console.error('Error: User access token not found in environment.');",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/users?username={{USER_ID}}&exact=true&briefRepresentation=true",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"users"
									],
									"query": [
										{
											"key": "username",
											"value": "{{USER_ID}}"
										},
										{
											"key": "exact",
											"value": "true"
										},
										{
											"key": "briefRepresentation",
											"value": "true"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Reset/Forgot Password via Email",
					"item": [
						{
							"name": "1 - Login - User",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const jsonData = pm.response.json();",
											"const currentFolder = FolderNames.forgotPasswordFolder;",
											"pm.test('User Login: Status code should be 200', function () {",
											"    pm.response.to.have.status(200);",
											"    console.log('User login successful with status code 200.');",
											"});",
											"if (jsonData && jsonData.access_token) {",
											"    FolderVariables.setVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\", jsonData.access_token);",
											"    console.log('User access token set successfully.');",
											"} else {",
											"    console.error('Error: No access token found in response.');",
											"    pm.test('User Login: Access token should be present', function () {",
											"        pm.expect(jsonData.access_token).to.exist;",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "client_credentials",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{USER_MGMT_CLIENT_ID}}",
											"type": "text"
										},
										{
											"key": "client_secret",
											"value": "{{USER_MGMT_CLIENT_SECRET}}",
											"type": "text"
										}
									]
								},
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/token",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"token"
									]
								}
							},
							"response": []
						},
						{
							"name": "2 - Get User (Email)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"const email = pm.request.url.query.get(\"email\");",
											"const user = Utilities.getUserIdByCriteria(pm, email, \"email\");",
											"const currentFolder = FolderNames.forgotPasswordFolder;",
											"FolderVariables.setVariable(pm, currentFolder, \"USER_ID\", user.userId);",
											"pm.test('User ID retrieved successfully', function () {",
											"    pm.expect(user.userId).to.not.be.null;",
											"    pm.expect(user.userId).to.not.be.undefined;",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.forgotPasswordFolder;",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/users?email=kzuser1@example.com&exact=true&briefRepresentation=true",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"users"
									],
									"query": [
										{
											"key": "email",
											"value": "kzuser1@example.com"
										},
										{
											"key": "exact",
											"value": "true"
										},
										{
											"key": "briefRepresentation",
											"value": "true"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "3 - Update Password - Trigger Email",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.forgotPasswordFolder;",
											"const userId = FolderVariables.getVariable(pm, currentFolder, \"USER_ID\");",
											"pm.environment.set(\"USER_ID\", userId);",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);",
											"pm.test('User ID and Access Token set correctly', function () {",
											"    pm.expect(userId).to.not.be.null;",
											"    pm.expect(accessToken).to.not.be.null;",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ID\");",
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"",
											"if (pm.response.code === 204) {",
											"    pm.test('Password reset email sent successfully', function () {",
											"        pm.response.to.have.status(204);",
											"    });",
											"    console.log('Password reset email sent successfully.');",
											"} else {",
											"    console.error('Failed to send password reset email:', pm.response.body);",
											"    pm.test('Failed to send password reset email', function () {",
											"        pm.response.to.have.status(204);",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "[\"UPDATE_PASSWORD\"]"
								},
								"url": {
									"raw": "{{BASE_URL}}/admin/realms/{{USER_REALM_NAME}}/users/{{USER_ID}}/execute-actions-email",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"users",
										"{{USER_ID}}",
										"execute-actions-email"
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "Reset Password Directly",
					"item": [
						{
							"name": "1 - Login - User",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const jsonData = pm.response.json();",
											"const currentFolder = FolderNames.resetPasswordFolder;",
											"pm.test('User Login: Status code should be 200', function () {",
											"    pm.response.to.have.status(200);",
											"    console.log('User login successful with status code 200.');",
											"});",
											"if (jsonData && jsonData.access_token) {",
											"    FolderVariables.setVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\", jsonData.access_token);",
											"    console.log('User access token set successfully.');",
											"} else {",
											"    console.error('Error: No access token found in response.');",
											"    pm.test('User Login: Access token should be present', function () {",
											"        pm.expect(jsonData.access_token).to.exist;",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "client_credentials",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{USER_MGMT_CLIENT_ID}}",
											"type": "text"
										},
										{
											"key": "client_secret",
											"value": "{{USER_MGMT_CLIENT_SECRET}}",
											"type": "text"
										}
									]
								},
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/token",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"token"
									]
								}
							},
							"response": []
						},
						{
							"name": "2 - Get User (Email)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"const email = pm.request.url.query.get(\"email\");",
											"const user = Utilities.getUserIdByCriteria(pm, email, \"email\");",
											"const currentFolder = FolderNames.resetPasswordFolder;",
											"FolderVariables.setVariable(pm, currentFolder, \"USER_ID\", user.userId);",
											"pm.test('User ID retrieved successfully', function () {",
											"    pm.expect(user.userId).to.not.be.null;",
											"    pm.expect(user.userId).to.not.be.undefined;",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.resetPasswordFolder;",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/users?email=kzuser1@example.com&exact=true&briefRepresentation=true",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"users"
									],
									"query": [
										{
											"key": "email",
											"value": "kzuser1@example.com"
										},
										{
											"key": "exact",
											"value": "true"
										},
										{
											"key": "briefRepresentation",
											"value": "true"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "3 - Reset Password",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.resetPasswordFolder;",
											"const userId = FolderVariables.getVariable(pm, currentFolder, \"USER_ID\");",
											"if (!userId) {",
											"    console.error('USER_ID is missing. Cannot reset password.');",
											"    pm.test('USER_ID is missing', function () {",
											"        pm.expect(userId).to.not.be.null;",
											"    });",
											"} else {",
											"    pm.environment.set(\"USER_ID\", userId);",
											"    console.log(`USER_ID is set: ${userId}`);",
											"}",
											"const username = FolderVariables.getVariable(pm, currentFolder, \"USER_NAME\");",
											"pm.environment.set(\"USER_NAME\", username);",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"if (!accessToken) {",
											"    console.error('Access token is missing. Cannot reset password.');",
											"    pm.test('Access token is missing', function () {",
											"        pm.expect(accessToken).to.not.be.null;",
											"    });",
											"} else {",
											"    pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);",
											"    console.log('Access token is set for reset password request');",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ID\");",
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"if (pm.response.code === 204) {",
											"    pm.test('Password reset successfully', function () {",
											"        pm.response.to.have.status(204);",
											"    });",
											"    console.log('Password reset successfully.');",
											"} else {",
											"    console.error('Failed to reset password:', pm.response.body);",
											"    pm.test('Failed to reset password', function () {",
											"        pm.response.to.have.status(204);",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"type\": \"password\",\r\n  \"value\": \"password1\",\r\n  \"temporary\": false\r\n}\r\n"
								},
								"url": {
									"raw": "{{BASE_URL}}/admin/realms/{{USER_REALM_NAME}}/users/{{USER_ID}}/reset-password",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"users",
										"{{USER_ID}}",
										"reset-password"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "Config Management",
			"item": [
				{
					"name": "Update Client Props",
					"item": [
						{
							"name": "1 - Login - User",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const jsonData = pm.response.json();",
											"const currentFolder = FolderNames.updateClientPropsFolder;",
											"pm.test('User Login: Status code should be 200', function () {",
											"    pm.response.to.have.status(200);",
											"    console.log('User login successful with status code 200.');",
											"});",
											"if (jsonData && jsonData.access_token) {",
											"    FolderVariables.setVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\", jsonData.access_token);",
											"    console.log('User access token set successfully.');",
											"} else {",
											"    console.error('Error: No access token found in response.');",
											"    pm.test('User Login: Access token should be present', function () {",
											"        pm.expect(jsonData.access_token).to.exist;",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "client_credentials",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{CLIENT_MGMT_CLIENT_ID}}",
											"type": "text"
										},
										{
											"key": "client_secret",
											"value": "{{CLIENT_MGMT_CLIENT_SECRET}}",
											"type": "text"
										}
									]
								},
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/token",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"token"
									]
								}
							},
							"response": []
						},
						{
							"name": "2 - Client Info",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const jsonData = pm.response.json();",
											"const currentFolder = FolderNames.updateClientPropsFolder;",
											"",
											"pm.test(\"Response contains client array with at least one item\", function () {",
											"    pm.expect(jsonData).to.be.an(\"array\").that.is.not.empty;",
											"});",
											"",
											"pm.test(\"First client in array has a valid UUID\", function () {",
											"    pm.expect(jsonData[0]).to.have.property(\"id\").that.is.a(\"string\").with.length.greaterThan(0);",
											"});",
											"",
											"if (jsonData && jsonData.length > 0 && jsonData[0].id) {",
											"    FolderVariables.setVariable(pm, currentFolder, \"CLIENT_UUID\", jsonData[0].id);",
											"    const clientUUID = FolderVariables.getVariable(pm, currentFolder, \"CLIENT_UUID\");",
											"    console.log(`CLIENT_UUID for ${currentFolder} is: ${clientUUID}`);",
											"",
											"    pm.test(\"CLIENT_UUID is set correctly\", function () {",
											"        pm.expect(clientUUID).to.not.be.null;",
											"        pm.expect(clientUUID).to.not.be.undefined;",
											"    });",
											"",
											"} else {",
											"    console.error('Client UUID not found in response');",
											"    pm.test('Client UUID validation failed', function () {",
											"        pm.expect(false, 'Client UUID missing').to.be.true;",
											"    });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.updateClientPropsFolder;",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"if (!accessToken) {",
											"    console.error('No USER_ACCESS_TOKEN found. Abort the request.');",
											"    pm.test('Check Access Token', function () {",
											"        pm.expect(false, 'Access token is missing').to.be.true;",
											"    });",
											"} else {",
											"    pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);",
											"    console.log('Using USER_ACCESS_TOKEN:', accessToken.substring(0, 60) + '...');",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{BASE_URL}}/admin/realms/{{USER_REALM_NAME}}/clients?clientId={{CLIENT_MGMT_CLIENT_ID}}",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"clients"
									],
									"query": [
										{
											"key": "clientId",
											"value": "{{CLIENT_MGMT_CLIENT_ID}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "3 - Update Client",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const currentFolder = FolderNames.updateClientPropsFolder;",
											"const clientUUID = FolderVariables.getVariable(pm, currentFolder, \"CLIENT_UUID\");",
											"if (clientUUID) {",
											"    pm.environment.set(\"CLIENT_UUID\", clientUUID);",
											"} else {",
											"    console.error('CLIENT_UUID is missing. Abort the request.');",
											"    pm.test('Check Client UUID', function () {",
											"        pm.expect(false, 'Client UUID is missing').to.be.true;",
											"    });",
											"}",
											"const accessToken = FolderVariables.getVariable(pm, currentFolder, \"USER_ACCESS_TOKEN\");",
											"if (accessToken) {",
											"    pm.environment.set(\"USER_ACCESS_TOKEN\", accessToken);",
											"} else {",
											"    console.error('USER_ACCESS_TOKEN is missing. Abort the request.');",
											"    pm.test('Check Access Token', function () {",
											"        pm.expect(false, 'Access token is missing').to.be.true;",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.environment.unset(\"CLIENT_UUID\");",
											"pm.environment.unset(\"USER_ACCESS_TOKEN\");",
											"",
											"pm.test(\"Status code is 204 for successful update\", function () {",
											"    pm.response.to.have.status(204);",
											"});",
											"",
											"const status = pm.response.code;",
											"if (status === 204) {",
											"    console.log(\"Client updated successfully.\");",
											"    pm.test(\"Client updated successfully\", function () {",
											"        pm.expect(status).to.eql(204);",
											"    });",
											"} else {",
											"    console.error(\"Failed to update client. Status:\", status);",
											"    pm.test(\"Client update failed\", function () {",
											"        pm.expect(status, \"Client update status\").to.eql(204);",
											"    });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{USER_ACCESS_TOKEN}}",
										"type": "text"
									},
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"publicClient\": false,\r\n  \"standardFlowEnabled\": false,\r\n  \"serviceAccountsEnabled\": true,\r\n  \"directAccessGrantsEnabled\": false\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{BASE_URL}}/admin/realms/{{USER_REALM_NAME}}/clients/{{CLIENT_UUID}}",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"realms",
										"{{USER_REALM_NAME}}",
										"clients",
										"{{CLIENT_UUID}}"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "Verify URL Access",
			"item": [
				{
					"name": "Granted - Paths",
					"item": [
						{
							"name": "/robots.txt",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is text/plain\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/plain\");\r",
											"});\r",
											"pm.test(\"X-Forwarded-Host header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.be.undefined;\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/robots.txt",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"robots.txt"
									]
								}
							},
							"response": []
						},
						{
							"name": "/realms/{{USER_REALM_NAME}}",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"const REALM_NAME = pm.environment.get(\"USER_REALM_NAME\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"Cache-Control is no-cache\", function () {\r",
											"    pm.response.to.have.header(\"Cache-Control\", \"max-age=0, no-store\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is application/json\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.json();\r",
											"\r",
											"  // Manually parse BASE_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = BASE_URL.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    pm.expect(responseData).to.be.an('object');\r",
											"    pm.expect(responseData.public_key).to.exist;\r",
											"    pm.expect(responseData.realm).to.be.eq(REALM_NAME);\r",
											"    pm.expect(responseData['token-service']).to.eq(`${expectedBaseUrl}/realms/${REALM_NAME}/protocol/openid-connect`);\r",
											"    pm.expect(responseData['account-service']).to.eq(`${expectedBaseUrl}/realms/${REALM_NAME}/account`);\r",
											"  } else {\r",
											"    pm.fail(\"BASE_URL format is incorrect\");\r",
											"  }\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.be.undefined;\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "/realms/{{ADMIN_REALM_NAME}}",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"const REALM_NAME = pm.environment.get(\"ADMIN_REALM_NAME\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"Cache-Control is no-cache\", function () {\r",
											"    pm.response.to.have.header(\"Cache-Control\", \"max-age=0, no-store\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is application/json\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.json();\r",
											"\r",
											"  // Manually parse BASE_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = BASE_URL.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    pm.expect(responseData).to.be.an('object');\r",
											"    pm.expect(responseData.public_key).to.exist;\r",
											"    pm.expect(responseData.realm).to.be.eq(REALM_NAME);\r",
											"    pm.expect(responseData['token-service']).to.eq(`${expectedBaseUrl}/realms/${REALM_NAME}/protocol/openid-connect`);\r",
											"    pm.expect(responseData['account-service']).to.eq(`${expectedBaseUrl}/realms/${REALM_NAME}/account`);\r",
											"  } else {\r",
											"    pm.fail(\"BASE_URL format is incorrect\");\r",
											"  }\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.be.undefined;\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{ADMIN_REALM_NAME}}",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{ADMIN_REALM_NAME}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "/admin",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"const REALM_NAME = pm.environment.get(\"ADMIN_REALM_NAME\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"Cache-Control is no-cache\", function () {\r",
											"    pm.response.to.have.header(\"Cache-Control\", \"max-age=0, no-store\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is text/html\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/html\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"  pm.expect(responseData).to.include('Loading the Administration Console');\r",
											"  pm.expect(responseData).to.include('JavaScript is required to use the Administration Console.');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"\r",
											" // Manually parse BASE_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = BASE_URL.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    const cheerio = require('cheerio');\r",
											"\r",
											"    // Load the HTML response data into Cheerio\r",
											"    const $ = cheerio.load(responseData);\r",
											"\r",
											"    // Extract the JSON object from the <script> tag with id \"environment\"\r",
											"    const environmentScript = $('#environment').html();\r",
											"\r",
											"    // Parse the JSON string into an object\r",
											"    const environmentData = JSON.parse(environmentScript);\r",
											"\r",
											"    pm.expect(environmentData).to.be.an('object');\r",
											"    pm.expect(environmentData.authUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.authServerUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.serverBaseUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.consoleBaseUrl).to.be.eq(`/admin/${REALM_NAME}/console/`);\r",
											"  } else {\r",
											"    pm.fail(\"BASE_URL format is incorrect\");\r",
											"  }\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disabledSystemHeaders": {}
							},
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/admin",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin"
									]
								}
							},
							"response": []
						},
						{
							"name": "/admin/{{ADMIN_REALM_NAME}}/console",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"const REALM_NAME = pm.environment.get(\"ADMIN_REALM_NAME\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"Cache-Control is no-cache\", function () {\r",
											"    pm.response.to.have.header(\"Cache-Control\", \"max-age=0, no-store\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is text/html\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/html\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"  pm.expect(responseData).to.include('Loading the Administration Console');\r",
											"  pm.expect(responseData).to.include('JavaScript is required to use the Administration Console.');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"\r",
											" // Manually parse BASE_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = BASE_URL.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    const cheerio = require('cheerio');\r",
											"\r",
											"    // Load the HTML response data into Cheerio\r",
											"    const $ = cheerio.load(responseData);\r",
											"\r",
											"    // Extract the JSON object from the <script> tag with id \"environment\"\r",
											"    const environmentScript = $('#environment').html();\r",
											"\r",
											"    // Parse the JSON string into an object\r",
											"    const environmentData = JSON.parse(environmentScript);\r",
											"\r",
											"    pm.expect(environmentData).to.be.an('object');\r",
											"    pm.expect(environmentData.authUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.authServerUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.serverBaseUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.consoleBaseUrl).to.be.eq(`/admin/${REALM_NAME}/console/`);\r",
											"  } else {\r",
											"    pm.fail(\"BASE_URL format is incorrect\");\r",
											"  }\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disabledSystemHeaders": {}
							},
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/admin/{{ADMIN_REALM_NAME}}/console",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"{{ADMIN_REALM_NAME}}",
										"console"
									]
								}
							},
							"response": []
						},
						{
							"name": "/admin/{{USER_REALM_NAME}}/console",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"const REALM_NAME = pm.environment.get(\"USER_REALM_NAME\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"Cache-Control is no-cache\", function () {\r",
											"    pm.response.to.have.header(\"Cache-Control\", \"max-age=0, no-store\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is text/html\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/html\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"  pm.expect(responseData).to.include('Loading the Administration Console');\r",
											"  pm.expect(responseData).to.include('JavaScript is required to use the Administration Console.');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"\r",
											" // Manually parse BASE_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = BASE_URL.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    const cheerio = require('cheerio');\r",
											"\r",
											"    // Load the HTML response data into Cheerio\r",
											"    const $ = cheerio.load(responseData);\r",
											"\r",
											"    // Extract the JSON object from the <script> tag with id \"environment\"\r",
											"    const environmentScript = $('#environment').html();\r",
											"\r",
											"    // Parse the JSON string into an object\r",
											"    const environmentData = JSON.parse(environmentScript);\r",
											"\r",
											"    pm.expect(environmentData).to.be.an('object');\r",
											"    pm.expect(environmentData.authUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.authServerUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.serverBaseUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.consoleBaseUrl).to.be.eq(`/admin/${REALM_NAME}/console/`);\r",
											"  } else {\r",
											"    pm.fail(\"BASE_URL format is incorrect\");\r",
											"  }\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disabledSystemHeaders": {}
							},
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/admin/{{USER_REALM_NAME}}/console",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"admin",
										"{{USER_REALM_NAME}}",
										"console"
									]
								}
							},
							"response": []
						},
						{
							"name": "/realms/.../openid-connect",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"const REALM_NAME = pm.environment.get(\"USER_REALM_NAME\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"Cache-Control is no-cache\", function () {\r",
											"    pm.response.to.have.header(\"Cache-Control\", \"max-age=0, no-store\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is text/html\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/html\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"  pm.expect(responseData).to.include('Loading the Administration Console');\r",
											"  pm.expect(responseData).to.include('JavaScript is required to use the Administration Console.');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"\r",
											" // Manually parse BASE_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = BASE_URL.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    const cheerio = require('cheerio');\r",
											"\r",
											"    // Load the HTML response data into Cheerio\r",
											"    const $ = cheerio.load(responseData);\r",
											"\r",
											"    // Extract the JSON object from the <script> tag with id \"environment\"\r",
											"    const environmentScript = $('#environment').html();\r",
											"\r",
											"    // Parse the JSON string into an object\r",
											"    const environmentData = JSON.parse(environmentScript);\r",
											"\r",
											"    pm.expect(environmentData).to.be.an('object');\r",
											"    pm.expect(environmentData.authUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.authServerUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.serverBaseUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.consoleBaseUrl).to.be.eq(`/admin/${REALM_NAME}/console/`);\r",
											"  } else {\r",
											"    pm.fail(\"BASE_URL format is incorrect\");\r",
											"  }\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disabledSystemHeaders": {}
							},
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/auth?client_id=security-admin-console",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"auth"
									],
									"query": [
										{
											"key": "client_id",
											"value": "security-admin-console"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "/realms/{{ADMIN_REALM_NAME}}/account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"const REALM_NAME = pm.environment.get(\"ADMIN_REALM_NAME\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"Cache-Control is no-cache\", function () {\r",
											"    pm.response.to.have.header(\"Cache-Control\", \"max-age=0, no-store\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is text/html\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/html\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"  pm.expect(responseData).to.include('Loading the Account Console');\r",
											"  pm.expect(responseData).to.include('JavaScript is required to use the Account Console.');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"\r",
											" // Manually parse BASE_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = BASE_URL.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    const cheerio = require('cheerio');\r",
											"\r",
											"    // Load the HTML response data into Cheerio\r",
											"    const $ = cheerio.load(responseData);\r",
											"\r",
											"    // Extract the JSON object from the <script> tag with id \"environment\"\r",
											"    const environmentScript = $('#environment').html();\r",
											"\r",
											"    // Parse the JSON string into an object\r",
											"    const environmentData = JSON.parse(environmentScript);\r",
											"\r",
											"    pm.expect(environmentData).to.be.an('object');\r",
											"    pm.expect(environmentData.authUrl).to.be.eq(`${expectedBaseUrl}/`);\r",
											"    pm.expect(environmentData.authServerUrl).to.be.eq(`${expectedBaseUrl}/`);\r",
											"    pm.expect(environmentData.serverBaseUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.baseUrl).to.be.eq(`${expectedBaseUrl}/realms/${REALM_NAME}/account/`);\r",
											"  } else {\r",
											"    pm.fail(\"BASE_URL format is incorrect\");\r",
											"  }\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disabledSystemHeaders": {}
							},
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{ADMIN_REALM_NAME}}/account",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{ADMIN_REALM_NAME}}",
										"account"
									]
								}
							},
							"response": []
						},
						{
							"name": "/realms/{{USER_REALM_NAME}}/account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"const REALM_NAME = pm.environment.get(\"USER_REALM_NAME\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"Cache-Control is no-cache\", function () {\r",
											"    pm.response.to.have.header(\"Cache-Control\", \"max-age=0, no-store\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is text/html\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/html\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"  pm.expect(responseData).to.include('Loading the Account Console');\r",
											"  pm.expect(responseData).to.include('JavaScript is required to use the Account Console.');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header does not exist\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.be.undefined;\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"\r",
											" // Manually parse BASE_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = BASE_URL.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    const cheerio = require('cheerio');\r",
											"\r",
											"    // Load the HTML response data into Cheerio\r",
											"    const $ = cheerio.load(responseData);\r",
											"\r",
											"    // Extract the JSON object from the <script> tag with id \"environment\"\r",
											"    const environmentScript = $('#environment').html();\r",
											"\r",
											"    // Parse the JSON string into an object\r",
											"    const environmentData = JSON.parse(environmentScript);\r",
											"\r",
											"    pm.expect(environmentData).to.be.an('object');\r",
											"    pm.expect(environmentData.authUrl).to.be.eq(`${expectedBaseUrl}/`);\r",
											"    pm.expect(environmentData.authServerUrl).to.be.eq(`${expectedBaseUrl}/`);\r",
											"    pm.expect(environmentData.serverBaseUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.baseUrl).to.be.eq(`${expectedBaseUrl}/realms/${REALM_NAME}/account/`);\r",
											"  } else {\r",
											"    pm.fail(\"BASE_URL format is incorrect\");\r",
											"  }\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disabledSystemHeaders": {}
							},
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/realms/{{USER_REALM_NAME}}/account",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"account"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Denied - Paths",
					"item": [
						{
							"name": "/",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response status code is 403\", function () {\r",
											"    pm.response.to.have.status(403);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										""
									]
								}
							},
							"response": []
						},
						{
							"name": "/realms",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response status code is 403\", function () {\r",
											"    pm.response.to.have.status(403);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/realms",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"realms"
									]
								}
							},
							"response": []
						},
						{
							"name": "/resources",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response status code is 403\", function () {\r",
											"    pm.response.to.have.status(403);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/resources",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"resources"
									]
								}
							},
							"response": []
						},
						{
							"name": "/health",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response status code is 403\", function () {\r",
											"    pm.response.to.have.status(403);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/health",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"health"
									]
								}
							},
							"response": []
						},
						{
							"name": "/health/ready",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response status code is 403\", function () {\r",
											"    pm.response.to.have.status(403);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/health/ready",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"health",
										"ready"
									]
								}
							},
							"response": []
						},
						{
							"name": "/health/live",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response status code is 403\", function () {\r",
											"    pm.response.to.have.status(403);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/health/live",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"health",
										"live"
									]
								}
							},
							"response": []
						},
						{
							"name": "/metrics",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response status code is 403\", function () {\r",
											"    pm.response.to.have.status(403);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"Server header should just be 'Apache' without any extra info\", function () {\r",
											"    pm.response.to.have.header(\"Server\", \"Apache\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const BASE_URL = pm.environment.get(\"BASE_URL\");\r",
											"    const expectedHost = BASE_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{BASE_URL}}/metrics",
									"host": [
										"{{BASE_URL}}"
									],
									"path": [
										"metrics"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Proxy Headers",
					"item": [
						{
							"name": "Headers Verification",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const REALM_NAME = pm.environment.get(\"ADMIN_REALM_NAME\");\r",
											"const KEYCLOAK_DIRECT_URL = pm.environment.get(\"KEYCLOAK_DIRECT_URL\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = KEYCLOAK_DIRECT_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header is keycloak-server\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.equal('keycloak-server');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header is 192.168.182.123\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.equal('192.168.182.123');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header is 38497\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.equal('38497');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header is https\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.equal('https');\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is application/json\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.json();\r",
											"\r",
											"  // This has to be exactly same as the KC_HOSTNAME used in docker compose/.env file.\r",
											"  const KC_HOSTNAME = 'http://127.0.0.1:80';\r",
											"\r",
											"  // Manually parse KEYCLOAK_DIRECT_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = KC_HOSTNAME.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    pm.expect(responseData).to.be.an('object');\r",
											"    pm.expect(responseData.public_key).to.exist;\r",
											"    pm.expect(responseData.realm).to.be.eq(REALM_NAME);\r",
											"    pm.expect(responseData['token-service']).to.eq(`${expectedBaseUrl}/realms/${REALM_NAME}/protocol/openid-connect`);\r",
											"    pm.expect(responseData['account-service']).to.eq(`${expectedBaseUrl}/realms/${REALM_NAME}/account`);\r",
											"  } else {\r",
											"    pm.fail(\"KC_HOSTNAME format is incorrect\");\r",
											"  }\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "X-Forwarded-Host",
										"value": "keycloak-server",
										"description": "Random hostname but should be reflected in urls in response",
										"type": "text"
									},
									{
										"key": "X-Forwarded-For",
										"value": "192.168.182.123",
										"description": "Random IP address",
										"type": "text"
									},
									{
										"key": "X-Forwarded-Port",
										"value": "38497",
										"description": "Random port but should be reflected in urls in response",
										"type": "text"
									},
									{
										"key": "X-Forwarded-Proto",
										"value": "https",
										"description": "Random proto but should be reflected in urls in response",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{KEYCLOAK_DIRECT_URL}}/realms/{{ADMIN_REALM_NAME}}",
									"host": [
										"{{KEYCLOAK_DIRECT_URL}}"
									],
									"path": [
										"realms",
										"{{ADMIN_REALM_NAME}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Headers Verification Console",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const REALM_NAME = pm.environment.get(\"USER_REALM_NAME\");\r",
											"const KEYCLOAK_DIRECT_URL = pm.environment.get(\"KEYCLOAK_DIRECT_URL\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = KEYCLOAK_DIRECT_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header is keycloak-server\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.equal('keycloak-server');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header is 192.168.182.123\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.equal('192.168.182.123');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header is 38497\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.equal('38497');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header is https\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.equal('https');\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is application/json\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/html\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"\r",
											"  // This has to be exactly same as the KC_HOSTNAME used in docker compose/.env file.\r",
											"  const KC_HOSTNAME = 'http://127.0.0.1:80';\r",
											"\r",
											"  // Manually parse KEYCLOAK_DIRECT_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = KC_HOSTNAME.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    const cheerio = require('cheerio');\r",
											"\r",
											"    // Load the HTML response data into Cheerio\r",
											"    const $ = cheerio.load(responseData);\r",
											"\r",
											"    // Extract the JSON object from the <script> tag with id \"environment\"\r",
											"    const environmentScript = $('#environment').html();\r",
											"\r",
											"    // Parse the JSON string into an object\r",
											"    const environmentData = JSON.parse(environmentScript);\r",
											"\r",
											"    pm.expect(environmentData).to.be.an('object');\r",
											"    pm.expect(environmentData.authUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.authServerUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.serverBaseUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.consoleBaseUrl).to.be.eq(`/admin/${REALM_NAME}/console/`);\r",
											"  } else {\r",
											"    pm.fail(\"KC_HOSTNAME format is incorrect\");\r",
											"  }\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "X-Forwarded-Host",
										"value": "keycloak-server",
										"description": "Random hostname but should be reflected in urls in response",
										"type": "text"
									},
									{
										"key": "X-Forwarded-For",
										"value": "192.168.182.123",
										"description": "Random IP address",
										"type": "text"
									},
									{
										"key": "X-Forwarded-Port",
										"value": "38497",
										"description": "Random port but should be reflected in urls in response",
										"type": "text"
									},
									{
										"key": "X-Forwarded-Proto",
										"value": "https",
										"description": "Random proto but should be reflected in urls in response",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{KEYCLOAK_DIRECT_URL}}/realms/{{USER_REALM_NAME}}/protocol/openid-connect/auth?client_id=security-admin-console",
									"host": [
										"{{KEYCLOAK_DIRECT_URL}}"
									],
									"path": [
										"realms",
										"{{USER_REALM_NAME}}",
										"protocol",
										"openid-connect",
										"auth"
									],
									"query": [
										{
											"key": "client_id",
											"value": "security-admin-console"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Headers Verification Account Copy",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"\r",
											"const REALM_NAME = pm.environment.get(\"ADMIN_REALM_NAME\");\r",
											"const KEYCLOAK_DIRECT_URL = pm.environment.get(\"KEYCLOAK_DIRECT_URL\");\r",
											"\r",
											"pm.test(\"Response status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response time is within acceptable range\", function () {\r",
											"  pm.expect(pm.response.responseTime).to.be.below(500);\r",
											"});\r",
											"\r",
											"pm.test(\"X-Frame-Options is SAMEORIGIN\", function () {\r",
											"    pm.response.to.have.header(\"X-Frame-Options\", \"SAMEORIGIN\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-Content-Type-Options is nosniff\", function () {\r",
											"    pm.response.to.have.header(\"X-Content-Type-Options\", \"nosniff\");\r",
											"});\r",
											"\r",
											"pm.test(\"X-XSS-Protection is set\", function () {\r",
											"    pm.response.to.have.header(\"X-XSS-Protection\", \"1; mode=block\");\r",
											"});\r",
											"\r",
											"pm.test(\"Strict-Transport-Security is configured\", function () {\r",
											"    pm.response.to.have.header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\");\r",
											"});\r",
											"\r",
											"// Validate ProxyPreserveHost Behavior\r",
											"pm.test(\"Host header is preserved by Apache\", function () {\r",
											"    const expectedHost = KEYCLOAK_DIRECT_URL.replace(/^https?:\\/\\//, '');\r",
											"    pm.expect(pm.request.headers.get(\"Host\")).to.equal(expectedHost);\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Host header is keycloak-server\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Host\")).to.equal('keycloak-server');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-For header is 192.168.182.123\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-For\")).to.equal('192.168.182.123');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Port header is 38497\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Port\")).to.equal('38497');\r",
											"});\r",
											"\r",
											"pm.test(\"X-Forwarded-Proto header is https\", function () {\r",
											"    pm.expect(pm.request.headers.get(\"X-Forwarded-Proto\")).to.equal('https');\r",
											"});\r",
											"\r",
											"pm.test(\"Content type is application/json\", function () {\r",
											"    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/html\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate the response schema for required fields\", function () {\r",
											"  const responseData = pm.response.text();\r",
											"\r",
											"  // This has to be exactly same as the KC_HOSTNAME used in docker compose/.env file.\r",
											"  const KC_HOSTNAME = 'http://127.0.0.1:80';\r",
											"\r",
											"  // Manually parse KEYCLOAK_DIRECT_URL (extract protocol, hostname, and port)\r",
											"  const regex = /^(https?):\\/\\/([^\\/:]+)(?::(\\d+))?/;\r",
											"  const matches = KC_HOSTNAME.match(regex);\r",
											"\r",
											"  if (matches) {\r",
											"    const protocol = matches[1];\r",
											"    const hostname = matches[2];\r",
											"    const port = matches[3] || (protocol === 'https' ? '443' : '80'); // Default to 443 for https, 80 for http\r",
											"    const expectedBaseUrl = port !== '80' && port !== '443' ? `${protocol}://${hostname}:${port}` : `${protocol}://${hostname}`;\r",
											"\r",
											"    const cheerio = require('cheerio');\r",
											"\r",
											"    // Load the HTML response data into Cheerio\r",
											"    const $ = cheerio.load(responseData);\r",
											"\r",
											"    // Extract the JSON object from the <script> tag with id \"environment\"\r",
											"    const environmentScript = $('#environment').html();\r",
											"\r",
											"    // Parse the JSON string into an object\r",
											"    const environmentData = JSON.parse(environmentScript);\r",
											"\r",
											"    pm.expect(environmentData).to.be.an('object');\r",
											"    pm.expect(environmentData.authUrl).to.be.eq(`${expectedBaseUrl}/`);\r",
											"    pm.expect(environmentData.authServerUrl).to.be.eq(`${expectedBaseUrl}/`);\r",
											"    pm.expect(environmentData.serverBaseUrl).to.be.eq(expectedBaseUrl);\r",
											"    pm.expect(environmentData.baseUrl).to.be.eq(`${expectedBaseUrl}/realms/${REALM_NAME}/account/`);\r",
											"  } else {\r",
											"    pm.fail(\"KC_HOSTNAME format is incorrect\");\r",
											"  }\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "X-Forwarded-Host",
										"value": "keycloak-server",
										"description": "Random hostname but should be reflected in urls in response",
										"type": "text"
									},
									{
										"key": "X-Forwarded-For",
										"value": "192.168.182.123",
										"description": "Random IP address",
										"type": "text"
									},
									{
										"key": "X-Forwarded-Port",
										"value": "38497",
										"description": "Random port but should be reflected in urls in response",
										"type": "text"
									},
									{
										"key": "X-Forwarded-Proto",
										"value": "https",
										"description": "Random proto but should be reflected in urls in response",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{KEYCLOAK_DIRECT_URL}}/realms/{{ADMIN_REALM_NAME}}/account",
									"host": [
										"{{KEYCLOAK_DIRECT_URL}}"
									],
									"path": [
										"realms",
										"{{ADMIN_REALM_NAME}}",
										"account"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					"// Collection-level variable manager\r",
					"FolderNames = {\r",
					"    logoutFolder: \"logoutFolder\",\r",
					"    userInfoFolder: \"userInfoFolder\",\r",
					"    deleteUserFolder: \"deleteUserFolder\",\r",
					"    refreshTokenFolder: \"refreshTokenFolder\",\r",
					"    resetPasswordFolder: \"resetPasswordFolder\",\r",
					"    forgotPasswordFolder: \"forgotPasswordFolder\",\r",
					"    updateClientPropsFolder: \"updateClientPropsFolder\",\r",
					"    updateClientPropsFolder: \"updateClientPropsFolder\",\r",
					"};\r",
					"\r",
					"FolderVariables = {};\r",
					"FolderVariables.setVariable = (pmInstance, folder, name, value) => {\r",
					"    // Get or create the folder-specific variable object\r",
					"    let folderData = pmInstance.collectionVariables.get(\"FolderData\") || \"{}\";\r",
					"    folderData = JSON.parse(folderData);\r",
					"\r",
					"    // Set variable within the specific folder's object\r",
					"    if (!folderData[folder]) folderData[folder] = {};\r",
					"    folderData[folder][name] = value;\r",
					"\r",
					"    pmInstance.collectionVariables.set(\"FolderData\", JSON.stringify(folderData));\r",
					"};\r",
					"FolderVariables.getVariable = (pmInstance, folder, name) => {\r",
					"    let folderData = pmInstance.collectionVariables.get(\"FolderData\") || \"{}\";\r",
					"    folderData = JSON.parse(folderData);\r",
					"\r",
					"    return folderData[folder] ? folderData[folder][name] : null;\r",
					"};\r",
					"FolderVariables.clearFolderVariables = (pmInstance, folder) => {\r",
					"    let folderData = pmInstance.collectionVariables.get(\"FolderData\") || \"{}\";\r",
					"    folderData = JSON.parse(folderData);\r",
					"\r",
					"    delete folderData[folder];\r",
					"    pmInstance.collectionVariables.set(\"FolderData\", JSON.stringify(folderData));\r",
					"};"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					"// Object.prototype.getUserIdByCriteria = (value, searchBy = 'username') => {...}\r",
					"// pm.getUserIdByCriteria('username', 'username');\r",
					"Utilities = {};\r",
					"Utilities.getUserIdByCriteria = (pmInstance, value, searchBy = 'username') => {\r",
					"    const users = pmInstance.response.json();\r",
					"\r",
					"    // Check if we're searching by email or username\r",
					"    let exactUser;\r",
					"    if (searchBy === 'email') {\r",
					"        exactUser = users.filter(user => user.email === value);\r",
					"    } else {\r",
					"        exactUser = users.filter(user => user.username === value);\r",
					"    }\r",
					"\r",
					"    if (exactUser.length === 1) {\r",
					"        const user = { userId: exactUser[0].id, username: exactUser[0].username };\r",
					"        return user;\r",
					"    } else {\r",
					"        // Return undefined if no user or multiple users found\r",
					"        return undefined;\r",
					"    }\r",
					"};\r",
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "FolderData",
			"value": ""
		}
	]
}